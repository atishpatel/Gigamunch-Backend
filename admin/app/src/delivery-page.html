<link rel="import"
      href="../bower_components/polymer/polymer-element.html">
<link rel="import"
      href="../bower_components/paper-button/paper-button.html">
<link rel="import"
      href="../bower_components/paper-progress/paper-progress.html">
<link rel="import"
      href="../bower_components/google-map/google-map.html">
<link rel="import"
      href="shared-styles.html">

<dom-module id="delivery-page">
  <template>
    <shared-styles>
      <style include="shared-styles">
        :host {
          display: block;
          padding: 10px;
        }

        paper-progress {
          padding: 12px;
          width: auto;
        }

        .table-container {
          padding: 12px 0;
        }

        .table-title {
          font-size: 14px;
        }

        google-map {
          height: 800px;
        }

        .table {
          display: table;
          width: 100%;
          border: 1px solid #000;
        }

        .table-header-row {
          background-color: #ccc;
          display: table-header-group;
          font-weight: bold;
        }

        .table-row {
          display: table-row;
          width: auto;
          clear: both;
        }

        .table-cell {
          border: 1px solid #999999;
          padding: 3px 10px;
          display: table-cell;
          flex: 1;
          /*display: flex;*/
          justify-content: space-between;
          align-items: center;
        }

        .table-body {
          display: table-row-group;
        }

        .delivery-count {
          padding: 12px 0;
        }

      </style>
    </shared-styles>

    <h1 class="">[[dateString]]</h1>
    <div>
      <select id="driverSelect"
              disabled="[[optimizeInProgress]]"
              value="{{driverName::change}}"
              required>
          <option disabled selected value> -- select an driver -- </option>
          <template is="dom-repeat"
                    items="[[drivers]]"
                    as="driver">
            <option value="[[driver.name]]">[[driver.name]]</option>
          </template>
        </select>
      <paper-button disabled="[[optimizeInProgress]]"
                    on-click="optimizeDriverRoute">Optimize driver route</paper-button>
      <paper-progress hidden$="[[!optimizeInProgress]]"
                      value="[[routeOptimizeProgress]]"></paper-progress>
    </div>

    <div class="table-container">
      <h2>Delivery Tools</h2>
      <div>
        <div class="table">
          <div class="table-row table-header-row">
            <div class="table-cell">Driver</div>
            <div class="table-cell">Name</div>
            <div class="table-cell">Delivery Tip</div>
            <div class="table-cell">APT</div>
            <div class="table-cell">Address</div>
            <div class="table-cell">Phone Number</div>
            <div class="table-cell">Servings</div>
            <div class="table-cell">Veg Servings</div>
            <div class="table-cell">Status</div>
            <div class="table-cell">Email</div>
          </div>
          <dom-repeat id="drivers-repeat"
                      items="[[drivers]]"
                      as="driver">
            <template>
              <dom-repeat items="[[driver.deliveries]]"
                          as="delivery">
                <template>
                  <div class="table-row">
                    <div class="table-cell">[[driver.name]]</div>
                    <div class="table-cell">[[delivery.name]]</div>
                    <div class="table-cell">[[delivery.delivery_tips]]</div>
                    <div class="table-cell">[[delivery.apt]]</div>
                    <div class="table-cell">[[delivery.addressStr]]</div>
                    <div class="table-cell">[[delivery.phone_number]]</div>
                    <div class="table-cell">[[delivery.servings]]</div>
                    <div class="table-cell">[[delivery.vegetarian_servings]]</div>
                    <div class="table-cell">[[delivery.status]]</div>
                    <div class="table-cell">[[delivery.sub_email]]</div>
                  </div>
                </template>
              </dom-repeat>
            </template>
          </dom-repeat>
        </div>
        <div class="delivery-count">
          <h2>Summary</h2>
          <div class="table">
            <div class="table-row table-header-row">
              <div class="table-cell">Driver</div>
              <div class="table-cell">Deliveries</div>
              <div class="table-cell">Optimized</div>
            </div>
            <dom-repeat id="drivers-repeat"
                        items="[[drivers]]"
                        as="driver">
              <template>
                <div class="table-row">
                  <div class="table-cell">[[driver.name]]</div>
                  <div class="table-cell">[[driver.deliveries.length]]</div>
                  <div class="table-cell">[[driver.optimized]]</div>
                </div>
              </template>
            </dom-repeat>
          </div>
        </div>
        <div class="table">
          <div class="table-row table-header-row">
            <div class="table-cell">Total</div>
            <div class="table-cell">[[totalDeliveries]]</div>
          </div>
        </div>
        <br>
        <h2>Map</h2>
        <google-map id="map"
                    map="{{map}}"
                    fit-to-marker
                    disable-street-view-control
                    latitude="36.16"
                    longitude="-86.78"
                    api-key="[[apiKey]]">
        </google-map>
      </div>
    </div>
  </template>
  <script src="../js/dep/BpTspSolver.js"></script>
  <script>
    class DeliveryPage extends Polymer.Element {
      static get is() {
        return 'delivery-page';
      }

      static get properties() {
        return {
          serviceold: {
            type: Object,
          },
          user: {
            type: Object,
            notify: true,
          },
          apiKey: {
            type: String,
            value: () => {
              return APP.IsProd ? 'AIzaSyApF3OWhumB5GeD20vQn_9NmToR0glkkOA' : 'AIzaSyAQOn9gsSWBu9nImfATaPKkSFp2I5MxbuU';
            },
          },
          drivers: {
            type: Array,
          },
          totalDeliveries: {
            type: Number,
          },
          driverName: {
            type: String,
          },
          dateString: {
            type: String,
          },
          polys: {
            type: Object,
          },
          map: {
            type: Object,
          },
          optimizeInProgress: {
            type: Boolean,
            value: false,
          },
          routeOptimizeProgress: {
            type: Number,
            value: 0,
          }
        }
      }

      static get observers() {
        return [ /* observer descriptors */ ]
      }

      constructor() {
        super();
        window.addEventListener('updateDriver', this.updateDriverHandler.bind(this));
      }

      connectedCallback() {
        super.connectedCallback();
      }

      selected() {
        const tmp = window.location.pathname.split('/delivery/');
        const dateString = decodeURIComponent(tmp[1]);
        let d;
        if (dateString === 'next') {
          d = new Date();
          while (d.getDay() !== 1) {
            d.setTime(d.getTime() + 24 * 3600 * 1000); // next day
          }
          d = new Date(d.toLocaleDateString() + ' 12:00:00');
        } else {
          d = new Date(dateString);
        }
        this.getSubLogsForDate(d);
      }

      getSubLogsForDate(d) {
        this.serviceold.getSubLogsForDate(d, (slogs, err) => {
          if (err.code !== 0) {
            return;
          }
          // process sublogs
          let unskippedSublogs = [];
          for (let i = 0; i < slogs.length; i++) {
            if (!slogs[i].skip) {
              slogs[i].apt = slogs[i].address.apt;

              function getAddress(a) {
                if (a && a.street) {
                  if (/\d/.test(a.street)) {
                    return `${a.street}, ${a.city}, ${a.state} ${a.zip}`;
                  }
                  let apt = '';
                  if (a.apt) {
                    apt = a.apt + ' ';
                  }
                  return `${apt} ${a.street}, ${a.city}, ${a.state} ${a.zip}`;
                }
                return '';
              }
              slogs[i].addressStr = getAddress(slogs[i].address);
              slogs[i].latlng = this._createGoogleLatlng(slogs[i].address.latitude, slogs[i].address.longitude);
              slogs[i].status = this._getStatus(slogs[i]);
              unskippedSublogs.push(slogs[i]);
            }
          }
          // convert to driver struct
          this.dateString = this._getDateString(slogs[0].date);
          this.drivers = this.getDrivers(unskippedSublogs);
          this.totalDeliveries = unskippedSublogs.length;
          this.setPolygons();
        });
      }

      /* =====================
         Route optimize
         =====================
      */

      // optimizeDriverRoute optimizes the route for a driver.
      optimizeDriverRoute() {
        const name = this.driverName;

        function errorCallback(e, e2) {
          console.error('tsp solver error: ', e, e2);
          alert('tsp solver error: ', e, e2);
        }
        this.drivers.forEach((driver) => {
          // find the driver
          if (driver.name === name && driver.deliveries.length > 1) {
            this.optimizeInProgress = true;
            // setup tsp
            if (!this.tsp) {
              this.tsp = new BpTspSolver(this.map, null, errorCallback, errorCallback);
            }
            let tsp = this.tsp;
            tsp.startOver();
            tsp.setOnProgressCallback(this.onProgressCallback.bind(this));
            tsp.setTravelMode(google.maps.DirectionsTravelMode.DRIVING);
            google.maps.event.addListener(tsp.getGDirectionsService(), "error", function() {
              this.optimizeInProgress = false;
              alert("Request failed: " + reasons[tsp.getGDirectionsService().getStatus().code]);
              console.error("Request failed: " + reasons[tsp.getGDirectionsService().getStatus().code]);
            });
            // add the deliveries as waypoints
            driver.deliveries.forEach((delivery) => {
              tsp.addWaypointWithLabel(this._createGoogleLatlng(delivery.address.latitude, delivery.address.longitude), delivery.name, null);
            });
            const startLatlng = this._createGoogleLatlng(driver.start_latlng);
            tsp.addWaypointWithLabel(startLatlng, 'Start');
            tsp.setAsStart(startLatlng);
            // optimize
            if (driver.round_trip) {
              tsp.solveRoundTrip(this.onSuccessCallback.bind(this));
            } else {
              const endLatlng = this._createGoogleLatlng(driver.end_latlng);
              tsp.addWaypointWithLabel(endLatlng, 'End');
              tsp.setAsStop(endLatlng);
              tsp.solveAtoZ(this.onSuccessCallback.bind(this));
            }
          }
        });
      }

      _createGoogleLatlng(lat, lng) {
        let latitude, longitude;
        if (typeof lat === 'object') {
          latitude = lat.lat;
          longitude = lat.lng;
        } else {
          latitude = lat;
          longitude = lng;
        }
        return new google.maps.LatLng(Number(latitude), Number(longitude));
      }

      // onProgressCallback updates the progress bar.
      onProgressCallback(tsp) {
        const progress = 100 * tsp.getNumDirectionsComputed() / tsp.getNumDirectionsNeeded();
        let diff = progress - this.routeOptimizeProgress;
        diff = diff < 0 ? diff * -1 : diff;
        if (diff > 1) {
          this.routeOptimizeProgress = progress;
        }
      }

      // onSuccessCallback updates the table and map based on the optimal route.
      onSuccessCallback(tsp) {
        this.optimizeInProgress = false;
        const drivers = this.drivers.slice();
        this.set('drivers', []);
        for (let i = 0; i < drivers.length; i++) {
          const driver = drivers[i];
          if (driver.name === this.driverName) {
            console.log('old delivery route: ', driver.deliveries);
            const newRoute = [];
            const order = tsp.getOrder();
            for (let j = 1; j < order.length - 1; j++) {
              newRoute.push(driver.deliveries[order[j] - 1]);
            }
            console.log('new delivery route: ', newRoute);
            drivers[i].deliveries = newRoute;
            if (drivers[i].directionsRenderer) {
              drivers[i].directionsRenderer.setMap(null);
            }
            // show route in map
            drivers[i].directionsRenderer = new google.maps.DirectionsRenderer({
              directions: tsp.getGDirections(),
              map: this.map,
              suppressMarkers: true,
            });
            drivers[i].optimized = true;
            break;
          }
        }
        setTimeout(() => {
          this.set('drivers', drivers);
        }, 1000);
      }

      /* =================
         Driver stuct code
         =================
      */
      getDrivers(sublogs) {
        if (!sublogs.length) {
          return;
        }
        let drivers = this._getGeofences();
        let indexOfNoDriver = drivers.length;
        drivers.push({
          name: '-',
          color: '#607D8B',
          desc: 'Catch All',
          round_trip: true,
          start_latlng: {
            lat: 36.268554,
            lng: -86.628631
          },
          end_latlng: {
            lat: 36.268554,
            lng: -86.628631
          },
        });

        for (let i = 0; i < drivers.length; i++) {
          drivers[i].deliveries = [];
          drivers[i].optimized = false;

          function pinSymbol(color) {
            return {
              path: 'M 0,0 C -2,-20 -10,-22 -10,-30 A 10,10 0 1,1 10,-30 C 10,-22 2,-20 0,0 z M -2,-30 a 2,2 0 1,1 4,0 2,2 0 1,1 -4,0',
              fillColor: color,
              fillOpacity: 1,
              strokeColor: '#000',
              strokeWeight: 2,
              scale: 1,
              labelOrigin: new google.maps.Point(0, 10)
            };
          }
          drivers[i].pinSymbol = pinSymbol(drivers[i].color);
        }
        let cache = JSON.parse(window.localStorage.getItem(this.dateString));
        if (!cache) {
          cache = {};
        }
        sublogs.forEach((sublog) => {
          let found = false;

          // add pin marker in map
          function makeMarker(t, sublog, driver) {
            return new google.maps.Marker({
              position: {
                lat: Number(sublog.address.latitude),
                lng: Number(sublog.address.longitude)
              },
              map: t.map,
              icon: driver.pinSymbol,
              label: sublog.name,
              draggable: true,
            });
          }

          // add popup in map
          function addMarkerPopup(sublog, driver) {
            google.maps.event.addListener(sublog.marker, 'click', function(event) {
              const labelStr = '<b>' + sublog.name + '</b><br>';
              const driverStr = `Driver: ${driver.name}<br>`;
              const addrStr = sublog.addressStr + '<br>';
              let changeDriverList = '<hr>';
              for (let i = 0; i < drivers.length; i++) {
                changeDriverList += `<span onclick="APP.Event.Fire(\'updateDriver\', {driverName:\'${drivers[i].name }\', deliveryEmail:\'${sublog.sub_email}\'})" style="color: #899BA3;cursor: pointer;text-decoration: underline;">Set driver to ${drivers[i].name}</span><br>`
              }
              const infoWindow = new google.maps.InfoWindow({
                content: labelStr + driverStr + addrStr + changeDriverList,
                position: sublog.marker.getPosition()
              });
              sublog.marker.infoWindow = infoWindow;
              infoWindow.open(this.map);
            });
          }

          for (let i = 0; i < drivers.length; i++) {
            const driver = drivers[i];
            if (driver.name === '-') {
              continue;
            }
            let isDriver = false;
            if (cache[sublog.sub_email]) {
              isDriver = cache[sublog.sub_email] === driver.name;
            } else {
              isDriver = this._inside(Number(sublog.address.latitude), Number(sublog.address.longitude), driver.geofence);
            }
            if (isDriver) {
              // in driver's geofence
              // add map marker
              sublog.marker = makeMarker(this, sublog, driver);
              // add map marker popup window
              addMarkerPopup(sublog, driver)
              // add delivery to driver
              driver.deliveries.push(sublog);
              found = true;
              break;
            }
          }
          // if not in a driver's geofence
          if (!found) {
            drivers[indexOfNoDriver].deliveries.push(sublog);
            // add map marker
            sublog.marker = makeMarker(this, sublog, drivers[indexOfNoDriver]);
            // add map marker popup window
            addMarkerPopup(sublog, drivers[indexOfNoDriver])
          }
        });
        return drivers;
      }

      updateDriverHandler(e) {
        this.updateDriver(e.detail.driverName, e.detail.deliveryEmail)
      }

      // updateDriver reassinges a delivery to another driver.
      updateDriver(driverName, deliveryEmail) {
        let delivery;
        let drivers = this.drivers;
        this.set('drivers', []);
        let cache = JSON.parse(window.localStorage.getItem(this.dateString));
        if (!cache) {
          cache = {};
        }
        // remove from old driver
        for (let i = 0; i < drivers.length; i++) {
          for (let j = 0; j < drivers[i].deliveries.length; j++) {
            if (drivers[i].deliveries[j].sub_email === deliveryEmail) {
              console.log(`removing ${deliveryEmail} from ${drivers[i].name}`);
              delivery = drivers[i].deliveries.splice(j, 1);
            }
          }
        }
        if (!delivery.length) {
          console.error(`no delivery with email(${deliveryEmail}) found`);
          return
        }
        // add to new driver
        for (let i = 0; i < drivers.length; i++) {
          if (drivers[i].name === driverName) {
            console.log(`adding ${deliveryEmail} to ${drivers[i].name}`);
            delivery[0].marker.setIcon(drivers[i].pinSymbol);
            drivers[i].deliveries.push(delivery[0]);
            drivers[i].optimized = false;
          }
        }
        cache[deliveryEmail] = driverName;
        window.localStorage.setItem(this.dateString, JSON.stringify(cache));
        setTimeout(() => {
          this.set('drivers', drivers);
        }, 1000);
      }

      // _inside checks if point is inside a geofence.
      _inside(lat, long, vs) {
        // ray-casting algorithm based on
        // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html

        var x = long,
          y = lat;

        var inside = false;
        for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
          var xi = vs[i][0],
            yi = vs[i][1];
          var xj = vs[j][0],
            yj = vs[j][1];

          var intersect = ((yi > y) != (yj > y)) &&
            (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
          if (intersect) inside = !inside;
        }

        return inside;
      };

      _getGeofences() {
        return [{
            name: 'Enis',
            desc: 'Franklin',
            color: '#3F51B5',
            round_trip: false,
            start_latlng: {
              lat: 36.127325,
              lng: -86.710504
            },
            end_latlng: {
              lat: 36.268554,
              lng: -86.628631
            },
            geofence: [
              [-86.6917419, 36.0035625],
              [-86.8263245, 35.9735608],
              [-86.9413376, 35.9771727],
              [-86.9554008, 35.8976451],
              [-86.9059753, 35.8322883],
              [-86.7274475, 35.8222673],
              [-86.6546631, 35.8501003],
              [-86.6917419, 36.0035625],
            ],
          },
          {
            name: 'Atish',
            desc: 'Hendersonville',
            color: '#009688',
            round_trip: false,
            start_latlng: {
              lat: 36.127325,
              lng: -86.710504
            },
            end_latlng: {
              lat: 36.268554,
              lng: -86.628631
            },
            geofence: [
              [-86.602478, 36.2542406],
              [-86.5756989, 36.2647604],
              [-86.4390565, 36.4361992],
              [-86.8798828, 36.359375],
              [-86.8661499, 36.2487033],
              [-86.6872834, 36.2922329],
              [-86.602478, 36.2542406],
            ],
          },
          {
            name: 'Chris',
            desc: 'Hendersonville2',
            color: '#03A9F4',
            round_trip: false,
            start_latlng: {
              lat: 36.127325,
              lng: -86.710504
            },
            end_latlng: {
              lat: 36.268554,
              lng: -86.628631
            },
            geofence: [
              [-86.602478, 36.2542406],
              [-86.5756989, 36.2647604],
              [-86.583252, 36.316785],
            ],
          },
          {
            name: 'Piyush',
            desc: 'Hermitage',
            color: '#4CAF50',
            round_trip: false,
            start_latlng: {
              lat: 36.127325,
              lng: -86.710504
            },
            end_latlng: {
              lat: 36.268554,
              lng: -86.628631
            },
            geofence: [
              [-86.5612793, 36.0446575],
              [-86.4733887, 36.1622705],
              [-86.5180206, 36.2791537],
              [-86.6278839, 36.2398428],
              [-86.6580963, 36.1971875],
              [-86.7034149, 36.2370737],
              [-86.6986084, 36.1434199],
              [-86.7336273, 36.1162449],
              [-86.7023539, 36.0257448],
              [-86.6704559, 35.9613345],
              [-86.5612793, 36.0446575],
            ],
          },
          {
            name: 'Tim',
            desc: 'Brentwood',
            color: '#673AB7',
            round_trip: true,
            start_latlng: {
              lat: 36.127325,
              lng: -86.710504
            },
            end_latlng: {
              lat: 36.268554,
              lng: -86.628631
            },
            geofence: [
              [-86.7087364, 36.003146],
              [-86.732254, 36.078517],
              [-86.7725944, 36.1146501],
              [-86.8040943, 36.1194342],
              [-86.8081284, 36.1184635],
              [-86.8297577, 36.0893379],
              [-86.8386842, 35.9949521],
              [-86.7087364, 36.003146],
            ],
          },
          {
            name: 'Wofford',
            desc: 'Bellevue',
            color: '#E91E63',
            round_trip: true,
            start_latlng: {
              lat: 36.127325,
              lng: -86.710504
            },
            end_latlng: {
              lat: 36.118228,
              lng: -86.755293
            },
            geofence: [
              [-86.8657207, 36.1026538],
              [-87.0611572, 36.078517],
              [-87.0206452, 35.9518857],
              [-86.9551308, 35.9917881],
              [-86.8490327, 36.0177396],
              [-86.8458938, 36.0474335],
              [-86.8237494, 36.1023764],
              [-86.8445634, 36.1148599],
              [-86.8657207, 36.1026538],
            ],
          },
          {
            name: 'Eric',
            desc: 'EastNashville',
            color: '#FFC107',
            round_trip: true,
            start_latlng: {
              lat: 36.127325,
              lng: -86.710504
            },
            end_latlng: {
              lat: 36.118228,
              lng: -86.755293
            },
            geofence: [
              [-86.6855622, 36.2542407],
              [-86.6883162, 36.2766773],
              [-86.7707257, 36.2674092],
              [-86.8064117, 36.2348583],
              [-86.8173981, 36.1982958],
              [-86.8046929, 36.1714086],
              [-86.7784309, 36.1708627],
              [-86.7713974, 36.1631032],
              [-86.7574882, 36.1592214],
              [-86.7521667, 36.1628248],
              [-86.7020416, 36.1750198],
              [-86.6972351, 36.1938628],
              [-86.7113089, 36.240388],
              [-86.6855622, 36.2542407],
            ],
          },
          {
            name: 'Todd',
            desc: 'Vanderbilt',
            color: '#CDDC39',
            round_trip: true,
            start_latlng: {
              lat: 36.127325,
              lng: -86.710504
            },
            end_latlng: {
              lat: 36.118228,
              lng: -86.755293
            },
            geofence: [
              [-86.8198014, 36.1978802],
              [-86.839714, 36.1672596],
              [-86.8228867, 36.1368329],
              [-86.8344756, 36.1147878],
              [-86.8161106, 36.1079934],
              [-86.8022118, 36.1291403],
              [-86.7957733, 36.144946],
              [-86.7950821, 36.1514597],
              [-86.8198014, 36.1978802],
            ],
          },
          {
            name: 'Libby',
            desc: 'Sylvan',
            color: '#FF5722',
            round_trip: true,
            start_latlng: {
              lat: 36.127325,
              lng: -86.710504
            },
            end_latlng: {
              lat: 36.118228,
              lng: -86.755293
            },
            geofence: [
              [-86.8405723, 36.1670517],
              [-86.8852101, 36.1939336],
              [-86.8874439, 36.1529848],
              [-86.9138718, 36.1167996],
              [-86.8669121, 36.103208],
              [-86.8536185, 36.1123619],
              [-86.8340476, 36.1164507],
              [-86.8242618, 36.1368327],
              [-86.8405723, 36.1670517],
            ],
          },
          {
            name: 'Brea',
            desc: 'Downtown',
            color: '#795548',
            round_trip: true,
            start_latlng: {
              lat: 36.127325,
              lng: -86.710504
            },
            end_latlng: {
              lat: 36.118228,
              lng: -86.755293
            },
            geofence: [
              [-86.7504501, 36.1231782],
              [-86.7689896, 36.1610231],
              [-86.7792892, 36.1694768],
              [-86.8043518, 36.1703083],
              [-86.7938421, 36.1484807],
              [-86.8064975, 36.120509],
              [-86.7782168, 36.1162655],
              [-86.7504501, 36.1231782],
            ],
          },
          {
            name: 'Aaron',
            desc: 'Unknown',
            color: '#03A9F4',
            round_trip: true,
            start_latlng: {
              lat: 36.127325,
              lng: -86.710504
            },
            end_latlng: {
              lat: 36.118228,
              lng: -86.755293
            },
            geofence: [
              [-86.7504501, 36.1231782],
              [-86.7689896, 36.1610231],
              [-86.7792892, 36.1694768],
            ],
          },
          {
            name: 'Extra Driver',
            desc: 'Unknown',
            color: '#000000',
            round_trip: true,
            start_latlng: {
              lat: 36.127325,
              lng: -86.710504
            },
            end_latlng: {
              lat: 36.118228,
              lng: -86.755293
            },
            geofence: [
              [-86.7504501, 36.1231782],
              [-86.7689896, 36.1610231],
              [-86.7792892, 36.1694768],
            ],
          },
          // {
          //   name: 'Enis',
          //   desc: 'Downtown',
          //   color: '#F44336',
          //   start_latlng: {
          //     lat: 36.127325,
          //     lng: -86.710504
          //   },
          //   end_latlng: {
          //     lat: 36.118228,
          //     lng: -86.755293
          //   },
          //   geofence: [
          //     [-86.7882156, 36.1966334],
          //     [-86.8134499, 36.1881826],
          //     [-86.7938805, 36.1511824],
          //     [-86.782727, 36.1450846],
          //     [-86.765213, 36.1583898],
          //     [-86.775341, 36.1632406],
          //     [-86.7882156, 36.1966334],
          //   ],
          // },
        ]
      }

      // set polygons
      setPolygons() {
        var geofences = this._getGeofences();
        geofences.forEach((geofence) => {
          var path = [];
          geofence.geofence.forEach((point) => {
            path.push(new google.maps.LatLng(point[1], point[0]));
          });
          var polyline = new google.maps.Polyline({
            path: path,
            strokeColor: geofence.Color,
            strokeOpacity: .5,
            strokeWeight: 2,
          });
          polyline.setMap(this.map);
        });
      }

      _getStatus(sublog) {
        if (sublog.refunded) {
          return 'Refunded';
        } else if (sublog.free) {
          return 'Free';
        } else if (sublog.paid) {
          return 'Paid';
        } else if (sublog.skip) {
          return 'Skipped';
        }
        return 'Unpaid';
      }

      _getDateString(dateString) {
        const d = new Date(dateString);
        return d.toUTCString().substring(0, 16);
      }
    }

    customElements.define(DeliveryPage.is, DeliveryPage);

  </script>
</dom-module>
